package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io"
	"os"
	"slices"
	"sort"
	"strings"

	"github.com/open-sspm/open-sspm-spec/tools/osspec/internal/types"
)

func main() {
	in, err := io.ReadAll(os.Stdin)
	if err != nil {
		fail(err)
	}
	var req types.CodegenRequest
	if err := json.Unmarshal(in, &req); err != nil {
		fail(fmt.Errorf("parse request: %w", err))
	}
	if req.SchemaVersion != 1 || req.Kind != "opensspm.codegen_request" {
		fail(fmt.Errorf("invalid request header: schema_version=%d kind=%q", req.SchemaVersion, req.Kind))
	}
	if req.Language != "go" {
		fail(fmt.Errorf("unsupported language %q", req.Language))
	}

	specCode, err := generateSpecTypes(req)
	if err != nil {
		fail(err)
	}
	runtimeCode, err := generateRuntimeTypes(req)
	if err != nil {
		fail(err)
	}

	resp := types.CodegenResponse{
		SchemaVersion: 1,
		Kind:          "opensspm.codegen_response",
		Files: []types.CodegenFile{
			{Path: "opensspm/spec/v1/types.gen.go", Content: specCode},
			{Path: "opensspm/runtime/v1/runtime.gen.go", Content: runtimeCode},
		},
	}
	out, err := json.Marshal(resp)
	if err != nil {
		fail(err)
	}
	os.Stdout.Write(out)
}

func fail(err error) {
	fmt.Fprintln(os.Stderr, err.Error())
	os.Exit(1)
}

func generateSpecTypes(req types.CodegenRequest) (string, error) {
	var b bytes.Buffer
	b.WriteString("// Code generated by osspec-gen-go. DO NOT EDIT.\n\n")
	b.WriteString("package v1\n\n")
	b.WriteString("import \"encoding/json\"\n\n")

	// Enums from dictionary.json (sorted by enum name).
	enums := req.Descriptor.Dictionary.Object.Dictionary.Enums
	names := make([]string, 0, len(enums))
	for k := range enums {
		names = append(names, k)
	}
	sort.Strings(names)
	for _, name := range names {
		values := append([]string(nil), enums[name]...)
		slices.Sort(values)
		values = slices.Compact(values)

		b.WriteString("type " + sanitizeGoIdent(name) + " string\n\n")
		b.WriteString("const (\n")
		for _, v := range values {
			constName := sanitizeGoIdent(name) + "_" + sanitizeGoIdent(strings.ToUpper(v))
			b.WriteString("\t" + constName + " " + sanitizeGoIdent(name) + " = " + quote(v) + "\n")
		}
		b.WriteString(")\n\n")
	}

	// Core spec model (mirrors compiler descriptor model).
	b.WriteString(`type Header struct {
	SchemaVersion int    ` + "`json:\"schema_version\"`" + `
	Kind          string ` + "`json:\"kind\"`" + `
}

type Version struct {
	Project             string ` + "`json:\"project\"`" + `
	Repo                string ` + "`json:\"repo\"`" + `
	SpecVersion         string ` + "`json:\"spec_version\"`" + `
	SchemaVersion       int    ` + "`json:\"schema_version\"`" + `
	GeneratorMinVersion string ` + "`json:\"generator_min_version\"`" + `
}

type Reference struct {
	Title string        ` + "`json:\"title,omitempty\"`" + `
	URL   string        ` + "`json:\"url\"`" + `
	Type  ReferenceType ` + "`json:\"type,omitempty\"`" + `
}

type Scope struct {
	Kind          ScopeKind ` + "`json:\"kind\"`" + `
	ConnectorKind string    ` + "`json:\"connector_kind,omitempty\"`" + `
}

type Source struct {
	Name    string ` + "`json:\"name\"`" + `
	Version string ` + "`json:\"version\"`" + `
	Date    string ` + "`json:\"date\"`" + `
	URL     string ` + "`json:\"url,omitempty\"`" + `
}

type RulesetDoc struct {
	SchemaVersion int    ` + "`json:\"schema_version\"`" + `
	Kind          string ` + "`json:\"kind\"`" + `
	Ruleset       Ruleset ` + "`json:\"ruleset\"`" + `
}

type Ruleset struct {
	Key               string               ` + "`json:\"key\"`" + `
	Name              string               ` + "`json:\"name\"`" + `
	Scope             Scope                ` + "`json:\"scope\"`" + `
	Source            *Source              ` + "`json:\"source,omitempty\"`" + `
	Status            string               ` + "`json:\"status,omitempty\"`" + `
	Description       string               ` + "`json:\"description,omitempty\"`" + `
	Tags              []string             ` + "`json:\"tags,omitempty\"`" + `
	References        []Reference          ` + "`json:\"references,omitempty\"`" + `
	FrameworkMappings []FrameworkMapping   ` + "`json:\"framework_mappings,omitempty\"`" + `
	Requirements      *RulesetRequirements ` + "`json:\"requirements,omitempty\"`" + `
	DataContracts     []DatasetContractRef ` + "`json:\"data_contracts,omitempty\"`" + `
	Rules             []Rule               ` + "`json:\"rules\"`" + `
}

type Rule struct {
	Key               string             ` + "`json:\"key\"`" + `
	Title             string             ` + "`json:\"title\"`" + `
	Severity          Severity           ` + "`json:\"severity\"`" + `
	Monitoring        Monitoring         ` + "`json:\"monitoring\"`" + `
	RequiredData      []string           ` + "`json:\"required_data\"`" + `
	Summary           string             ` + "`json:\"summary,omitempty\"`" + `
	Description       string             ` + "`json:\"description,omitempty\"`" + `
	Category          string             ` + "`json:\"category,omitempty\"`" + `
	Parameters        *Parameters        ` + "`json:\"parameters,omitempty\"`" + `
	Check             *Check             ` + "`json:\"check,omitempty\"`" + `
	Evidence          *Evidence          ` + "`json:\"evidence,omitempty\"`" + `
	Remediation       *Remediation       ` + "`json:\"remediation,omitempty\"`" + `
	References        []Reference        ` + "`json:\"references,omitempty\"`" + `
	FrameworkMappings []FrameworkMapping ` + "`json:\"framework_mappings,omitempty\"`" + `
	Tags              []string           ` + "`json:\"tags,omitempty\"`" + `
	Lifecycle         *Lifecycle         ` + "`json:\"lifecycle,omitempty\"`" + `
}

type Monitoring struct {
	Status MonitoringStatus ` + "`json:\"status\"`" + `
	Reason string           ` + "`json:\"reason,omitempty\"`" + `
}

type Parameters struct {
	Defaults map[string]any             ` + "`json:\"defaults\"`" + `
	Schema   map[string]ParameterSchema ` + "`json:\"schema,omitempty\"`" + `
}

type Check struct {
	Type CheckType ` + "`json:\"type\"`" + `

	DatasetVersion     int         ` + "`json:\"dataset_version,omitempty\"`" + `
	OnMissingDataset   ErrorPolicy ` + "`json:\"on_missing_dataset,omitempty\"`" + `
	OnPermissionDenied ErrorPolicy ` + "`json:\"on_permission_denied,omitempty\"`" + `
	OnSyncError        ErrorPolicy ` + "`json:\"on_sync_error,omitempty\"`" + `
	Notes              string      ` + "`json:\"notes,omitempty\"`" + `

	Dataset string      ` + "`json:\"dataset,omitempty\"`" + `
	Where   []Predicate ` + "`json:\"where,omitempty\"`" + `

	Assert *Predicate          ` + "`json:\"assert,omitempty\"`" + `
	Expect *FieldCompareExpect ` + "`json:\"expect,omitempty\"`" + `

	Compare *Compare ` + "`json:\"compare,omitempty\"`" + `

	Left            *JoinSide       ` + "`json:\"left,omitempty\"`" + `
	Right           *JoinSide       ` + "`json:\"right,omitempty\"`" + `
	OnUnmatchedLeft OnUnmatchedLeft ` + "`json:\"on_unmatched_left,omitempty\"`" + `
}

type Predicate struct {
	Path      string ` + "`json:\"path,omitempty\"`" + `
	LeftPath  string ` + "`json:\"left_path,omitempty\"`" + `
	RightPath string ` + "`json:\"right_path,omitempty\"`" + `
	Op        Operator ` + "`json:\"op\"`" + `
	Value     any      ` + "`json:\"value,omitempty\"`" + `
	ValueParam string  ` + "`json:\"value_param,omitempty\"`" + `
}

type Compare struct {
	Op        CompareOp ` + "`json:\"op\"`" + `
	Value     *int      ` + "`json:\"value,omitempty\"`" + `
	ValueParam string   ` + "`json:\"value_param,omitempty\"`" + `
}

type FieldCompareExpect struct {
	Match       FieldCompareMatch   ` + "`json:\"match,omitempty\"`" + `
	MinSelected int                ` + "`json:\"min_selected,omitempty\"`" + `
	OnEmpty     FieldCompareOnEmpty ` + "`json:\"on_empty,omitempty\"`" + `
}

type JoinSide struct {
	Dataset string ` + "`json:\"dataset\"`" + `
	KeyPath string ` + "`json:\"key_path\"`" + `
}

type DatasetRefSpec struct {
	Dataset string ` + "`json:\"dataset\"`" + `
	Version int    ` + "`json:\"version\"`" + `
}

type FrameworkMapping struct {
	Framework   string                ` + "`json:\"framework\"`" + `
	Control     string                ` + "`json:\"control\"`" + `
	Enhancement string                ` + "`json:\"enhancement,omitempty\"`" + `
	Coverage    FrameworkCoverageKind ` + "`json:\"coverage,omitempty\"`" + `
	Notes       string                ` + "`json:\"notes,omitempty\"`" + `
}

type RulesetRequirements struct {
	APIScopes   []string ` + "`json:\"api_scopes,omitempty\"`" + `
	Permissions []string ` + "`json:\"permissions,omitempty\"`" + `
	Notes       string   ` + "`json:\"notes,omitempty\"`" + `
}

type DatasetContractRef struct {
	Dataset     string ` + "`json:\"dataset\"`" + `
	Version     int    ` + "`json:\"version\"`" + `
	Description string ` + "`json:\"description,omitempty\"`" + `
}

type ParameterSchema struct {
	Type        string   ` + "`json:\"type\"`" + `
	Description string   ` + "`json:\"description,omitempty\"`" + `
	Minimum     *float64 ` + "`json:\"minimum,omitempty\"`" + `
	Maximum     *float64 ` + "`json:\"maximum,omitempty\"`" + `
	Enum        []any    ` + "`json:\"enum,omitempty\"`" + `
}

type Evidence struct {
	AffectedResources *AffectedResources     ` + "`json:\"affected_resources,omitempty\"`" + `
	SummaryTemplates  *EvidenceSummaryTemplates ` + "`json:\"summary_templates,omitempty\"`" + `
}

type AffectedResources struct {
	Dataset      string ` + "`json:\"dataset\"`" + `
	IDField      string ` + "`json:\"id_field\"`" + `
	DisplayField string ` + "`json:\"display_field\"`" + `
}

type EvidenceSummaryTemplates struct {
	Pass          string ` + "`json:\"pass,omitempty\"`" + `
	Fail          string ` + "`json:\"fail,omitempty\"`" + `
	Unknown       string ` + "`json:\"unknown,omitempty\"`" + `
	Error         string ` + "`json:\"error,omitempty\"`" + `
	NotApplicable string ` + "`json:\"not_applicable,omitempty\"`" + `
}

type Remediation struct {
	Instructions string            ` + "`json:\"instructions\"`" + `
	Risks        string            ` + "`json:\"risks,omitempty\"`" + `
	Effort       RemediationEffort ` + "`json:\"effort,omitempty\"`" + `
}

type Lifecycle struct {
	RuleVersion string ` + "`json:\"rule_version,omitempty\"`" + `
	IsActive    *bool  ` + "`json:\"is_active,omitempty\"`" + `
	ReplacedBy  string ` + "`json:\"replaced_by,omitempty\"`" + `
}

type DatasetContractDoc struct {
	SchemaVersion int    ` + "`json:\"schema_version\"`" + `
	Kind          string ` + "`json:\"kind\"`" + `
	Dataset       DatasetContract ` + "`json:\"dataset\"`" + `
}

type DatasetContract struct {
	Key                string          ` + "`json:\"key\"`" + `
	Version            int             ` + "`json:\"version\"`" + `
	Description        string          ` + "`json:\"description,omitempty\"`" + `
	PrimaryKey         string          ` + "`json:\"primary_key,omitempty\"`" + `
	RecommendedDisplay string          ` + "`json:\"recommended_display,omitempty\"`" + `
	Schema             json.RawMessage ` + "`json:\"schema\"`" + `
}

type ConnectorManifestDoc struct {
	SchemaVersion int    ` + "`json:\"schema_version\"`" + `
	Kind          string ` + "`json:\"kind\"`" + `
	Connector     ConnectorManifest ` + "`json:\"connector\"`" + `
}

type ConnectorManifest struct {
	Kind     string           ` + "`json:\"kind\"`" + `
	Name     string           ` + "`json:\"name\"`" + `
	Provides []DatasetRefSpec ` + "`json:\"provides\"`" + `
}

type ProfileDoc struct {
	SchemaVersion int    ` + "`json:\"schema_version\"`" + `
	Kind          string ` + "`json:\"kind\"`" + `
	Profile       Profile ` + "`json:\"profile\"`" + `
}

type Profile struct {
	Key         string              ` + "`json:\"key\"`" + `
	Name        string              ` + "`json:\"name\"`" + `
	Description string              ` + "`json:\"description,omitempty\"`" + `
	Rulesets    []ProfileRulesetRef ` + "`json:\"rulesets\"`" + `
}

type ProfileRulesetRef struct {
	Key     string ` + "`json:\"key\"`" + `
	Version string ` + "`json:\"version,omitempty\"`" + `
}

type DictionaryDoc struct {
	SchemaVersion int    ` + "`json:\"schema_version\"`" + `
	Kind          string ` + "`json:\"kind\"`" + `
	Dictionary    struct {
		Enums map[string][]string ` + "`json:\"enums\"`" + `
	} ` + "`json:\"dictionary\"`" + `
}

type Artifact struct {
	Kind       string ` + "`json:\"kind\"`" + `
	Key        string ` + "`json:\"key\"`" + `
	SourcePath string ` + "`json:\"source_path\"`" + `
	Hash       string ` + "`json:\"hash\"`" + `
}

type ArtifactsIndex struct {
	SchemaVersion int        ` + "`json:\"schema_version\"`" + `
	Kind          string     ` + "`json:\"kind\"`" + `
	Artifacts     []Artifact ` + "`json:\"artifacts\"`" + `
}

type RequirementsIndex struct {
	SchemaVersion int                  ` + "`json:\"schema_version\"`" + `
	Kind          string               ` + "`json:\"kind\"`" + `
	Rulesets      []RulesetRequirement ` + "`json:\"rulesets\"`" + `
}

type RulesetRequirement struct {
	RulesetKey  string           ` + "`json:\"ruleset_key\"`" + `
	Status      string           ` + "`json:\"status\"`" + `
	Scope       Scope            ` + "`json:\"scope\"`" + `
	Datasets    []DatasetRefSpec ` + "`json:\"datasets\"`" + `
	CheckTypes  []CheckType      ` + "`json:\"check_types\"`" + `
	ValueParams []string         ` + "`json:\"value_params\"`" + `
	Rules       []RuleRequirement ` + "`json:\"rules\"`" + `
}

type RuleRequirement struct {
	RuleKey     string           ` + "`json:\"rule_key\"`" + `
	IsManual    bool             ` + "`json:\"is_manual\"`" + `
	Datasets    []DatasetRefSpec ` + "`json:\"datasets\"`" + `
	CheckType   *CheckType       ` + "`json:\"check_type\"`" + `
	ValueParams []string         ` + "`json:\"value_params\"`" + `
	Monitoring  struct {
		Status MonitoringStatus ` + "`json:\"status\"`" + `
	} ` + "`json:\"monitoring\"`" + `
}

type Compiled[T any] struct {
	SourcePath string ` + "`json:\"source_path\"`" + `
	Hash       string ` + "`json:\"hash\"`" + `
	Object     T      ` + "`json:\"object\"`" + `
}

type DescriptorV1 struct {
	SchemaVersion    int                       ` + "`json:\"schema_version\"`" + `
	Kind             string                    ` + "`json:\"kind\"`" + `
	Version          Version                   ` + "`json:\"version\"`" + `
	Dictionary       Compiled[DictionaryDoc]   ` + "`json:\"dictionary\"`" + `
	Rulesets         []Compiled[RulesetDoc]    ` + "`json:\"rulesets\"`" + `
	DatasetContracts []Compiled[DatasetContractDoc] ` + "`json:\"dataset_contracts\"`" + `
	Connectors       []Compiled[ConnectorManifestDoc] ` + "`json:\"connectors\"`" + `
	Profiles         []Compiled[ProfileDoc]    ` + "`json:\"profiles\"`" + `
	Index            struct {
		Requirements RequirementsIndex ` + "`json:\"requirements\"`" + `
		Artifacts    ArtifactsIndex    ` + "`json:\"artifacts\"`" + `
	} ` + "`json:\"index\"`" + `
}

func ParseDescriptorV1(b []byte) (DescriptorV1, error) {
	var d DescriptorV1
	return d, json.Unmarshal(b, &d)
}
`)

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		return "", fmt.Errorf("format spec types: %w", err)
	}
	return string(formatted), nil
}

func generateRuntimeTypes(req types.CodegenRequest) (string, error) {
	var b bytes.Buffer
	b.WriteString("// Code generated by osspec-gen-go. DO NOT EDIT.\n\n")
	b.WriteString("package v1\n\n")
	b.WriteString("import (\n\t\"context\"\n\t\"encoding/json\"\n)\n\n")

	// Keep a stable copy of DatasetErrorKind constants in runtime package.
	enums := req.Descriptor.Dictionary.Object.Dictionary.Enums
	if values, ok := enums["DatasetErrorKind"]; ok {
		values = append([]string(nil), values...)
		slices.Sort(values)
		values = slices.Compact(values)

		b.WriteString("type DatasetErrorKind string\n\n")
		b.WriteString("const (\n")
		for _, v := range values {
			constName := "DatasetErrorKind_" + sanitizeGoIdent(strings.ToUpper(v))
			b.WriteString("\t" + constName + " DatasetErrorKind = " + quote(v) + "\n")
		}
		b.WriteString(")\n\n")
	}
	if values, ok := enums["ScopeKind"]; ok {
		values = append([]string(nil), values...)
		slices.Sort(values)
		values = slices.Compact(values)

		b.WriteString("type ScopeKind string\n\n")
		b.WriteString("const (\n")
		for _, v := range values {
			constName := "ScopeKind_" + sanitizeGoIdent(strings.ToUpper(v))
			b.WriteString("\t" + constName + " ScopeKind = " + quote(v) + "\n")
		}
		b.WriteString(")\n\n")
	}

	b.WriteString(`type EvalContext struct {
	ScopeKind         ScopeKind ` + "`json:\"scope_kind\"`" + `
	ConnectorKind     string    ` + "`json:\"connector_kind,omitempty\"`" + `
	ConnectorInstance string    ` + "`json:\"connector_instance,omitempty\"`" + `
}

type DatasetRef struct {
	Dataset string ` + "`json:\"dataset\"`" + `
	Version int    ` + "`json:\"version\"`" + `
}

type DatasetError struct {
	Kind    DatasetErrorKind ` + "`json:\"kind\"`" + `
	Message string           ` + "`json:\"message,omitempty\"`" + `
}

type DatasetResult struct {
	Rows  []json.RawMessage ` + "`json:\"rows,omitempty\"`" + `
	Error *DatasetError     ` + "`json:\"error,omitempty\"`" + `
}

type DatasetProvider interface {
	Capabilities(ctx context.Context) []DatasetRef
	GetDataset(ctx context.Context, eval EvalContext, ref DatasetRef) DatasetResult
}
`)

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		return "", fmt.Errorf("format runtime types: %w", err)
	}
	return string(formatted), nil
}

func sanitizeGoIdent(s string) string {
	if s == "" {
		return "X"
	}
	// Allow only [A-Za-z0-9_], force leading to letter/underscore.
	var b strings.Builder
	for i, r := range s {
		ok := (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_'
		if !ok {
			r = '_'
		}
		if i == 0 && (r >= '0' && r <= '9') {
			b.WriteByte('_')
		}
		b.WriteRune(r)
	}
	return b.String()
}

func quote(s string) string {
	b, _ := json.Marshal(s)
	return string(b)
}
